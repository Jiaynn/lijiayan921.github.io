<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构与算法</title>
      <link href="/2022/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
      <url>/2022/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><h4 id="二叉树的创建"><a href="#二叉树的创建" class="headerlink" title="二叉树的创建"></a>二叉树的创建</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeCode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//初始化二叉树</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BiTree</span>=<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>=val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lChild</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rChild</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">createTree</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> biTree=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> biTree</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="递归遍历二叉树"><a href="#递归遍历二叉树" class="headerlink" title="递归遍历二叉树"></a>递归遍历二叉树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//前序遍历：根左右</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">ProTraverse</span>(<span class="params">biTree</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">proOrder</span>=(<span class="params">biTree</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(biTree==<span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">    res.<span class="title function_">push</span>(biTree.<span class="property">data</span>)</span><br><span class="line">    <span class="title function_">proOrder</span>(biTree.<span class="property">lChild</span>)</span><br><span class="line">    <span class="title function_">proOrder</span>(biTree.<span class="property">rChild</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">proOrder</span>(biTree)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//中序遍历：左根右</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">biTree</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> res = [];</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">biTree</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!biTree) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">inorder</span>(biTree.<span class="property">lChild</span>);</span><br><span class="line">        res.<span class="title function_">push</span>(biTree.<span class="property">data</span>);</span><br><span class="line">        <span class="title function_">inorder</span>(biTree.<span class="property">rChild</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(biTree);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//后序遍历：左右根</span></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">PostTraverse</span>(<span class="params">biTree</span>)&#123;</span><br><span class="line">    <span class="keyword">let</span> res=[]</span><br><span class="line">    <span class="keyword">let</span> <span class="title function_">postOrder</span>=(<span class="params">biTree</span>)=&gt;&#123;</span><br><span class="line">    <span class="keyword">if</span>(biTree==<span class="literal">null</span>) <span class="keyword">return</span></span><br><span class="line">   </span><br><span class="line">    <span class="title function_">postOrder</span>(biTree.<span class="property">lChild</span>)</span><br><span class="line">    <span class="title function_">postOrder</span>(biTree.<span class="property">rChild</span>)</span><br><span class="line">    res.<span class="title function_">push</span>(biTree.<span class="property">data</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">postOrder</span>(biTree)</span><br><span class="line">    <span class="keyword">return</span> res</span><br><span class="line"> </span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myTree = <span class="keyword">new</span> <span class="title class_">TreeCode</span>();</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">inorderTraversal</span>(myTree.<span class="title function_">createTree</span>());</span><br><span class="line"><span class="keyword">let</span> res1=<span class="title class_">ProTraverse</span>(myTree.<span class="title function_">createTree</span>())</span><br><span class="line"><span class="keyword">let</span> res2=<span class="title class_">PostTraverse</span>(myTree.<span class="title function_">createTree</span>())</span><br></pre></td></tr></table></figure><h4 id="迭代遍历二叉树"><a href="#迭代遍历二叉树" class="headerlink" title="迭代遍历二叉树"></a>迭代遍历二叉树</h4><p><strong>前序遍历</strong></p><p>1、首先将中间节点入栈</p><p>2、出栈一个节点，将该节点的右节点先入栈，然后再将左节点入栈。为什么右节点先入栈？这样出栈时才是左节点先出栈，右节点后出栈，也就是前序遍历的‘中左右’</p><p>3、栈为空时就结束</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> preorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>()</span><br><span class="line">        ans.<span class="title function_">push</span>(node.<span class="property">data</span>)</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">rChild</span>) stack.<span class="title function_">push</span>(node.<span class="property">rChild</span>)</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">lChild</span>) stack.<span class="title function_">push</span>(node.<span class="property">lChild</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> res1=preorderTraversal (myTree.<span class="title function_">createTree</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br></pre></td></tr></table></figure><p><strong>中序遍历</strong></p><p>由于我们访问二叉树是从根节点，也就是中间节点开始，但是中序遍历要求先遍历左节点，因此我们需要记录中间节点，并先去访问它的左子树。<br>我们使用栈来记录节点<br>1、只要当前遍历到的节点不为空，就要记录该节点并且去访问该节点的左节点。<br>2、前节点为空时，说明左节点为空，需要将中间节点的值加入结果数组，此时的中间节点位于栈顶，将中间节点出栈，将它的值加入结果数组。<br>3、接下来访问右节点，右节点不为空，回到第一步，右节点为空，回到第二步。<br>当栈为空时结束遍历。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中序遍历迭代实现</span></span><br><span class="line"><span class="keyword">var</span> inorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    <span class="comment">// cur为当前节点</span></span><br><span class="line">    <span class="keyword">let</span> cur = root</span><br><span class="line">    <span class="keyword">while</span>(cur || stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur)&#123;</span><br><span class="line">            stack.<span class="title function_">push</span>(cur)</span><br><span class="line">            <span class="comment">// 遍历左节点</span></span><br><span class="line">            cur = cur.<span class="property">lChild</span></span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;  <span class="comment">//当前节点为空，要处理栈顶（中间）节点</span></span><br><span class="line">            <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>()</span><br><span class="line">            ans.<span class="title function_">push</span>(node.<span class="property">data</span>)</span><br><span class="line">            <span class="comment">// 中间节点遍历完，遍历右子树</span></span><br><span class="line">            cur = node.<span class="property">rChild</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myTree = <span class="keyword">new</span> <span class="title class_">TreeCode</span>();</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">inorderTraversal</span>(myTree.<span class="title function_">createTree</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><p><strong>后序遍历</strong></p><p>在前序遍历的基础上，先将左孩子入栈</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> postorderTraversal = <span class="keyword">function</span>(<span class="params">root</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">let</span> stack = []</span><br><span class="line">    <span class="keyword">let</span> ans = []</span><br><span class="line">    stack.<span class="title function_">push</span>(root)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(stack.<span class="property">length</span>)&#123;</span><br><span class="line">        <span class="keyword">const</span> node = stack.<span class="title function_">pop</span>()</span><br><span class="line">        ans.<span class="title function_">push</span>(node.<span class="property">data</span>)</span><br><span class="line">         <span class="keyword">if</span>(node.<span class="property">lChild</span>) stack.<span class="title function_">push</span>(node.<span class="property">lChild</span>)</span><br><span class="line">        <span class="keyword">if</span>(node.<span class="property">rChild</span>) stack.<span class="title function_">push</span>(node.<span class="property">rChild</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> res2=postorderTraversal (myTree.<span class="title function_">createTree</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res2);</span><br></pre></td></tr></table></figure><h3 id="重构二叉树"><a href="#重构二叉树" class="headerlink" title="重构二叉树"></a>重构二叉树</h3><h4 id="根据前序遍历和中序遍历实现二叉树"><a href="#根据前序遍历和中序遍历实现二叉树" class="headerlink" title="根据前序遍历和中序遍历实现二叉树"></a>根据前序遍历和中序遍历实现二叉树</h4><p>例如输入前序遍历序列<code>&#123;1,2,4,7,3,5,6,8&#125;</code>和中序遍历序列<code>&#123;4,7,2,1,5,3,8,6&#125;</code>，则重建二叉树并返回。</p><ul><li>前序遍历找到根结点<code>root</code></li><li>找到<code>root</code>在中序遍历的位置 -&gt; 左子树的长度和右子树的长度</li><li>截取左子树的中序遍历、右子树的中序遍历</li><li>截取左子树的前序遍历、右子树的前序遍历</li><li>递归重建二叉树</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TreeNode</span>=<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>=val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reConBiTree</span>(<span class="params">pre,vin</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">if</span>(pre.<span class="property">length</span>===<span class="number">1</span>) <span class="keyword">return</span> <span class="keyword">new</span> <span class="title class_">TreeNode</span>(pre[<span class="number">0</span>])</span><br><span class="line">    <span class="keyword">let</span> value=pre[<span class="number">0</span>]</span><br><span class="line">    <span class="comment">//得到根节点在中序遍历的位置</span></span><br><span class="line">    <span class="keyword">let</span> index=vin.<span class="title function_">indexOf</span>(value)</span><br><span class="line">    <span class="comment">//截取中序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">let</span> vinLeft=vin.<span class="title function_">slice</span>(<span class="number">0</span>,index)</span><br><span class="line">    <span class="comment">//截取中序遍历中的右子树</span></span><br><span class="line">    <span class="keyword">let</span> vinRight=vin.<span class="title function_">slice</span>(index+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//截取前序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">let</span> preLeft=pre.<span class="title function_">slice</span>(<span class="number">1</span>,index+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//截取前序遍历中的右子树</span></span><br><span class="line">    <span class="keyword">let</span> preRight=pre.<span class="title function_">slice</span>(index+<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(value)</span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">reConBiTree</span>(preLeft, vinLeft);</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">reConBiTree</span>(preRight, vinRight);</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> pre=[<span class="number">1</span>,<span class="number">2</span>,<span class="number">4</span>,<span class="number">7</span>,<span class="number">3</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">8</span>]</span><br><span class="line"><span class="keyword">let</span> ino=[<span class="number">4</span>,<span class="number">7</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> res= <span class="title function_">reConBiTree</span>(pre,ino)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h4 id="根据中序遍历和后序遍历重构二叉树"><a href="#根据中序遍历和后序遍历重构二叉树" class="headerlink" title="根据中序遍历和后序遍历重构二叉树"></a>根据中序遍历和后序遍历重构二叉树</h4><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="comment">//初始化二叉树</span></span><br><span class="line"><span class="keyword">let</span> <span class="title class_">TreeNode</span>=<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>=val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">left</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">right</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">reConBiTree</span>(<span class="params">vin,post</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(post.<span class="property">length</span>===<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">    <span class="keyword">let</span> value=post.<span class="title function_">pop</span>()</span><br><span class="line">    <span class="comment">//得到根节点在中序遍历的位置</span></span><br><span class="line">    <span class="keyword">let</span> index=vin.<span class="title function_">indexOf</span>(value)</span><br><span class="line">    <span class="comment">//截取中序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">let</span> vinLeft=vin.<span class="title function_">slice</span>(<span class="number">0</span>,index)</span><br><span class="line">    <span class="comment">//截取中序遍历中的右子树</span></span><br><span class="line">    <span class="keyword">let</span> vinRight=vin.<span class="title function_">slice</span>(index+<span class="number">1</span>)</span><br><span class="line">    <span class="comment">//截取后序遍历中的左子树</span></span><br><span class="line">    <span class="keyword">let</span> postLeft=post.<span class="title function_">slice</span>(<span class="number">0</span>,index)</span><br><span class="line">    <span class="comment">//截取后序遍历中的右子树</span></span><br><span class="line">    <span class="keyword">let</span> postRight=post.<span class="title function_">slice</span>(index)</span><br><span class="line">    <span class="keyword">let</span> node=<span class="keyword">new</span> <span class="title class_">TreeNode</span>(value)</span><br><span class="line">    node.<span class="property">left</span>=<span class="title function_">reConBiTree</span>(vinLeft, postLeft);</span><br><span class="line">    node.<span class="property">right</span>=<span class="title function_">reConBiTree</span>(vinRight, postRight);</span><br><span class="line">    <span class="keyword">return</span> node</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> ino=[<span class="number">9</span>,<span class="number">3</span>,<span class="number">15</span>,<span class="number">20</span>,<span class="number">7</span>]</span><br><span class="line"><span class="keyword">let</span> post=[<span class="number">9</span>,<span class="number">15</span>,<span class="number">7</span>,<span class="number">20</span>,<span class="number">3</span>]</span><br><span class="line"><span class="keyword">let</span> res= <span class="title function_">reConBiTree</span>(ino,post)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="对称二叉树"><a href="#对称二叉树" class="headerlink" title="对称二叉树"></a>对称二叉树</h3><img src="/2022/10/11/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/Web\自己总结的学习记录\md图片\QQ截图20220715190124.png" style="zoom: 50%;"><p>如图，1为对称二叉树，2、3都不是。</p><ul><li>两个根结点相等</li><li>左子树的右节点和右子树的左节点相同。</li><li>右子树的左节点和左子树的右节点相同。</li></ul><p>递归所有节点满足以上条件即二叉树对称。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> isSymmetric=<span class="keyword">function</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title function_">check</span>(root.<span class="property">lChild</span>,root.<span class="property">rChild</span>)</span><br><span class="line">    <span class="keyword">function</span> <span class="title function_">check</span>(<span class="params">left,right</span>)&#123;</span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>&amp;&amp;right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(left==<span class="literal">null</span>||right==<span class="literal">null</span>) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        <span class="keyword">return</span> left.<span class="property">data</span>==right.<span class="property">data</span>&amp;&amp;<span class="title function_">check</span>(left.<span class="property">left</span>,right.<span class="property">right</span>)&amp;&amp;<span class="title function_">check</span>(left.<span class="property">right</span>,right.<span class="property">left</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myTree = <span class="keyword">new</span> <span class="title class_">TreeCode</span>();</span><br><span class="line"><span class="keyword">let</span> res=<span class="title function_">isSymmetric</span>(myTree.<span class="title function_">createTree</span>())</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h3 id="镜像二叉树"><a href="#镜像二叉树" class="headerlink" title="镜像二叉树"></a>镜像二叉树</h3><p>操作给定的二叉树，将其变换为源二叉树的镜像。</p><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  源二叉树 </span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  6   10</span><br><span class="line"> / \  / \</span><br><span class="line">5  7 9 11</span><br><span class="line">镜像二叉树</span><br><span class="line">    8</span><br><span class="line">   /  \</span><br><span class="line">  10   6</span><br><span class="line"> / \  / \</span><br><span class="line">11 9 7  5</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>思路：递归交换二叉树所有节点左右节点的位置</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeCode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//初始化二叉树</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BiTree</span>=<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>=val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lChild</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rChild</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">createTree</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> biTree=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;10&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;9&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;11&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> biTree</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Mirror</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">let</span> temp=root.<span class="property">rChild</span></span><br><span class="line">    root.<span class="property">rChild</span>=root.<span class="property">lChild</span></span><br><span class="line">    root.<span class="property">lChild</span>=temp</span><br><span class="line">    <span class="title class_">Mirror</span>(root.<span class="property">lChild</span>)</span><br><span class="line">    <span class="title class_">Mirror</span>(root.<span class="property">rChild</span>)</span><br><span class="line">    <span class="keyword">return</span> root</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myTree = <span class="keyword">new</span> <span class="title class_">TreeCode</span>();</span><br><span class="line"><span class="keyword">let</span> res1=<span class="title class_">Mirror</span>(myTree.<span class="title function_">createTree</span>());</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res1);</span><br></pre></td></tr></table></figure><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p>给定一棵二叉搜索树，请找出其中的第k小的结点。 例如， （5，3，7，2，4，6，8） 中，按结点数值大小顺序第三小结点的值为4。</p><p>思路：通过输入的序列形成二叉树后，进行中序遍历，得到由小到大排序的数组，然后再根据k得到是第几个，然后返回</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeCode</span>(<span class="params"></span>)&#123;</span><br><span class="line">    <span class="comment">//初始化二叉树</span></span><br><span class="line">    <span class="keyword">let</span> <span class="title class_">BiTree</span>=<span class="keyword">function</span>(<span class="params">val</span>)&#123;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">data</span>=val</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">lChild</span>=<span class="literal">null</span>;</span><br><span class="line">        <span class="variable language_">this</span>.<span class="property">rChild</span>=<span class="literal">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="variable language_">this</span>.<span class="property">createTree</span>=<span class="keyword">function</span>(<span class="params"></span>)&#123;</span><br><span class="line">        <span class="keyword">let</span> biTree=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;5&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;3&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;7&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">lChild</span>.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>.<span class="property">lChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;6&#x27;</span>)</span><br><span class="line">        biTree.<span class="property">rChild</span>.<span class="property">rChild</span>=<span class="keyword">new</span> <span class="title class_">BiTree</span>(<span class="string">&#x27;8&#x27;</span>)</span><br><span class="line">        <span class="keyword">return</span> biTree</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title function_">Knode</span>(<span class="params">root,k</span>)&#123;</span><br><span class="line"><span class="keyword">let</span> arr=[]</span><br><span class="line"><span class="comment">//进行中序遍历得到由小到大顺序排列的数组</span></span><br><span class="line"><span class="title function_">inorderTraversal</span>(root,arr)</span><br><span class="line"><span class="keyword">if</span>(k&gt;<span class="number">0</span>&amp;&amp;k&lt;arr.<span class="property">length</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> arr[k-<span class="number">1</span>]</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">inorderTraversal</span>(<span class="params">biTree,arr</span>) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="title function_">inorder</span> = (<span class="params">biTree</span>) =&gt; &#123;</span><br><span class="line">        <span class="keyword">if</span> (!biTree) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="title function_">inorder</span>(biTree.<span class="property">lChild</span>);</span><br><span class="line">        arr.<span class="title function_">push</span>(biTree.<span class="property">data</span>);</span><br><span class="line">        <span class="title function_">inorder</span>(biTree.<span class="property">rChild</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="title function_">inorder</span>(biTree);</span><br><span class="line">    <span class="keyword">return</span> arr;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">let</span> myTree = <span class="keyword">new</span> <span class="title class_">TreeCode</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> res=<span class="title class_">Knode</span>(myTree.<span class="title function_">createTree</span>(),<span class="number">5</span>);</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h4 id="二叉排序树的后序遍历"><a href="#二叉排序树的后序遍历" class="headerlink" title="二叉排序树的后序遍历"></a>二叉排序树的后序遍历</h4><p>输入一个整数数组，判断该数组是不是某二叉排序的后序遍历的结果。如果是则输出true,否则输出false。假设输入的数组的任意两个数字都互不相同。</p><p>思路：</p><p>1.后序遍历：分成三部分：最后一个节点为根节点，第二部分为左子树的值比根节点都小，第三部分为右子树的值比根节点都大。</p><p>2.先检测左子树，左侧比根节点小的值都判定为左子树。</p><p>3.除最后一个节点外和左子树外的其他值为右子树，右子树有一个比根节点小，则返回false。</p><p>4.若存在，左、右子树，递归检测左、右子树是否复合规范。</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">VerifySquenceOfBST</span>(<span class="params">seq</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(seq&amp;&amp;seq.<span class="property">length</span>&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//获取根节点</span></span><br><span class="line">        <span class="keyword">let</span> root=seq[seq.<span class="property">length</span>-<span class="number">1</span>]</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>;i&lt;seq.<span class="property">length</span>-<span class="number">1</span>;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(seq[i]&gt;root)&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">let</span> j=i;j&lt;seq.<span class="property">length</span>-<span class="number">1</span>;j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(seq[j]&lt;root) <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">            &#125;</span><br><span class="line">      </span><br><span class="line">        <span class="keyword">let</span> left=<span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(i&gt;<span class="number">0</span>) left=<span class="title class_">VerifySquenceOfBST</span>(seq.<span class="title function_">slice</span>(<span class="number">0</span>,i))</span><br><span class="line">        <span class="keyword">let</span> right=<span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;seq.<span class="property">length</span>-<span class="number">1</span>) right=<span class="title class_">VerifySquenceOfBST</span>(seq.<span class="title function_">slice</span>(i,seq.<span class="property">length</span>-<span class="number">1</span>))</span><br><span class="line">        <span class="keyword">return</span> left&amp;&amp;right</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> seq=[<span class="number">2</span>,<span class="number">5</span>,<span class="number">3</span>,<span class="number">7</span>,<span class="number">9</span>,<span class="number">8</span>,<span class="number">6</span>]</span><br><span class="line"><span class="keyword">let</span> res=<span class="title class_">VerifySquenceOfBST</span>(seq)</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(res);</span><br></pre></td></tr></table></figure><h4 id="二叉树的最大深度"><a href="#二叉树的最大深度" class="headerlink" title="二叉树的最大深度"></a>二叉树的最大深度</h4><p>给定一个二叉树，找出其最大深度。</p><p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>，</p><figure class="highlight text"><table><tr><td class="code"><pre><span class="line">  3</span><br><span class="line"> / \</span><br><span class="line">9  20</span><br><span class="line">  /  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>返回它的最大深度 3 。</p><p>思路：一棵二叉树的最大深度等于左子树深度和右子树最大深度的最大值 + 1</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">TreeDepth</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> !root?<span class="number">0</span>:<span class="title class_">Math</span>.<span class="title function_">max</span>(<span class="title class_">TreeDepth</span>(root.<span class="property">lChild</span>),<span class="title class_">TreeDepth</span>(root.<span class="property">rChild</span>))+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的最小深度"><a href="#二叉树的最小深度" class="headerlink" title="二叉树的最小深度"></a>二叉树的最小深度</h3><p>给定一个二叉树，找出其最小深度。</p><p>最小深度是从根节点到最近叶子节点的最短路径上的节点数量。</p><p>给定二叉树 <code>[3,9,20,null,null,15,7]</code>,</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">  <span class="number">3</span></span><br><span class="line"> / \</span><br><span class="line"><span class="number">9</span>  <span class="number">20</span></span><br><span class="line">  /  \</span><br><span class="line"> <span class="number">15</span>   <span class="number">7</span></span><br></pre></td></tr></table></figure><p>返回它的最小深度 2</p><p>思路：</p><ul><li>左右子树都不为空：左子树深度和右子树最小深度的最小值 + 1</li><li>左树为空：右子树最小深度的最小值 + 1</li><li>右树为空：左子树最小深度 + 1</li></ul><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">minDepth</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!root) <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span>(!root.<span class="property">left</span>) <span class="keyword">return</span> <span class="title function_">minDepth</span>(root.<span class="property">rChild</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">if</span>(!root.<span class="property">right</span>) <span class="keyword">return</span> <span class="title function_">minDepth</span>(root.<span class="property">lChild</span>)+<span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">min</span>(<span class="title function_">minDepth</span>(root.<span class="property">rChild</span>),<span class="title function_">minDepth</span>(root.<span class="property">lChild</span>))+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p>输入一棵二叉树，判断该二叉树是否是平衡二叉树。</p><blockquote><p>平衡二叉树：每个子树的深度之差不超过1</p></blockquote><p>思路：</p><p>后序遍历二叉树</p><p>在遍历二叉树每个节点前都会遍历其左右子树</p><p>比较左右子树的深度，若差值大于1 则返回一个标记 -1表示当前子树不平衡</p><p>左右子树有一个不是平衡的，或左右子树差值大于1，则整课树不平衡</p><p>若左右子树平衡，返回当前树的深度（左右子树的深度最大值+1）</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title function_">IsBalanced</span>(<span class="params">root</span>)&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">IsBalanced</span>(root)!=-<span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">function</span> <span class="title function_">balanced</span>(<span class="params">node</span>)&#123;</span><br><span class="line">    <span class="keyword">if</span>(!node)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> left=<span class="title function_">balanced</span>(node.<span class="property">lChild</span>)</span><br><span class="line">    <span class="keyword">let</span> right=<span class="title function_">balanced</span>(node.<span class="property">rChild</span>)</span><br><span class="line">    <span class="keyword">if</span>(left==-<span class="number">1</span> || right==-<span class="number">1</span> || <span class="title class_">Math</span>.<span class="title function_">abs</span>(left-right)&gt;<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> -<span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="title class_">Math</span>.<span class="title function_">max</span>(left,right)+<span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
            <tag> 二叉树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的第一篇博客</title>
      <link href="/2022/10/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/10/10/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
